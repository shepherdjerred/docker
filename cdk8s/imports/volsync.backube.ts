// deno-lint-ignore-file
// generated by cdk8s
import {
  ApiObject,
  ApiObjectMetadata,
  GroupVersionKind,
} from "https://esm.sh/cdk8s@2.68.58";
import { Construct } from "https://esm.sh/constructs@10.3.0";

/**
 * A ReplicationDestination is a VolSync resource that you can use to define the destination of a VolSync replication
or synchronization.
 *
 * @schema ReplicationDestination
 */
export class ReplicationDestination extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationDestination"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "volsync.backube/v1alpha1",
    kind: "ReplicationDestination",
  };

  /**
   * Renders a Kubernetes manifest for "ReplicationDestination".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationDestinationProps = {}): any {
    return {
      ...ReplicationDestination.GVK,
      ...toJson_ReplicationDestinationProps(props),
    };
  }

  /**
   * Defines a "ReplicationDestination" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ReplicationDestinationProps = {},
  ) {
    super(scope, id, {
      ...ReplicationDestination.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationDestination.GVK,
      ...toJson_ReplicationDestinationProps(resolved),
    };
  }
}

/**
 * A ReplicationDestination is a VolSync resource that you can use to define the destination of a VolSync replication
 * or synchronization.
 *
 * @schema ReplicationDestination
 */
export interface ReplicationDestinationProps {
  /**
   * @schema ReplicationDestination#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * spec is the desired state of the ReplicationDestination, including the
   * replication method to use and its configuration.
   *
   * @schema ReplicationDestination#spec
   */
  readonly spec?: ReplicationDestinationSpec;
}

/**
 * Converts an object of type 'ReplicationDestinationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationProps(
  obj: ReplicationDestinationProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ReplicationDestinationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * spec is the desired state of the ReplicationDestination, including the
 * replication method to use and its configuration.
 *
 * @schema ReplicationDestinationSpec
 */
export interface ReplicationDestinationSpec {
  /**
   * external defines the configuration when using an external replication
   * provider.
   *
   * @schema ReplicationDestinationSpec#external
   */
  readonly external?: ReplicationDestinationSpecExternal;

  /**
   * paused can be used to temporarily stop replication. Defaults to "false".
   *
   * @default false".
   * @schema ReplicationDestinationSpec#paused
   */
  readonly paused?: boolean;

  /**
   * rclone defines the configuration when using Rclone-based replication.
   *
   * @schema ReplicationDestinationSpec#rclone
   */
  readonly rclone?: ReplicationDestinationSpecRclone;

  /**
   * restic defines the configuration when using Restic-based replication.
   *
   * @schema ReplicationDestinationSpec#restic
   */
  readonly restic?: ReplicationDestinationSpecRestic;

  /**
   * rsync defines the configuration when using Rsync-based replication.
   *
   * @schema ReplicationDestinationSpec#rsync
   */
  readonly rsync?: ReplicationDestinationSpecRsync;

  /**
   * rsyncTLS defines the configuration when using Rsync-based replication over TLS.
   *
   * @schema ReplicationDestinationSpec#rsyncTLS
   */
  readonly rsyncTls?: ReplicationDestinationSpecRsyncTls;

  /**
   * trigger determines if/when the destination should attempt to synchronize
   * data with the source.
   *
   * @schema ReplicationDestinationSpec#trigger
   */
  readonly trigger?: ReplicationDestinationSpecTrigger;
}

/**
 * Converts an object of type 'ReplicationDestinationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpec(
  obj: ReplicationDestinationSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "external": toJson_ReplicationDestinationSpecExternal(obj.external),
    "paused": obj.paused,
    "rclone": toJson_ReplicationDestinationSpecRclone(obj.rclone),
    "restic": toJson_ReplicationDestinationSpecRestic(obj.restic),
    "rsync": toJson_ReplicationDestinationSpecRsync(obj.rsync),
    "rsyncTLS": toJson_ReplicationDestinationSpecRsyncTls(obj.rsyncTls),
    "trigger": toJson_ReplicationDestinationSpecTrigger(obj.trigger),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * external defines the configuration when using an external replication
 * provider.
 *
 * @schema ReplicationDestinationSpecExternal
 */
export interface ReplicationDestinationSpecExternal {
  /**
   * parameters are provider-specific key/value configuration parameters. For
   * more information, please see the documentation of the specific
   * replication provider being used.
   *
   * @schema ReplicationDestinationSpecExternal#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * provider is the name of the external replication provider. The name
   * should be of the form: domain.com/provider.
   *
   * @schema ReplicationDestinationSpecExternal#provider
   */
  readonly provider?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecExternal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecExternal(
  obj: ReplicationDestinationSpecExternal | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "parameters": ((obj.parameters) === undefined)
      ? undefined
      : (Object.entries(obj.parameters).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "provider": obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rclone defines the configuration when using Rclone-based replication.
 *
 * @schema ReplicationDestinationSpecRclone
 */
export interface ReplicationDestinationSpecRclone {
  /**
   * accessModes specifies the access modes for the destination volume.
   *
   * @schema ReplicationDestinationSpecRclone#accessModes
   */
  readonly accessModes?: string[];

  /**
   * capacity is the size of the destination volume to create.
   *
   * @schema ReplicationDestinationSpecRclone#capacity
   */
  readonly capacity?: ReplicationDestinationSpecRcloneCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the destination
   * volume should be created.
   *
   * @schema ReplicationDestinationSpecRclone#copyMethod
   */
  readonly copyMethod?: ReplicationDestinationSpecRcloneCopyMethod;

  /**
   * customCA is a custom CA that will be used to verify the remote
   *
   * @schema ReplicationDestinationSpecRclone#customCA
   */
  readonly customCa?: ReplicationDestinationSpecRcloneCustomCa;

  /**
   * destinationPVC is a PVC to use as the transfer destination instead of
   * automatically provisioning one. Either this field or both capacity and
   * accessModes must be specified.
   *
   * @schema ReplicationDestinationSpecRclone#destinationPVC
   */
  readonly destinationPvc?: string;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationDestinationSpecRclone#moverAffinity
   */
  readonly moverAffinity?: ReplicationDestinationSpecRcloneMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationDestinationSpecRclone#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationDestinationSpecRclone#moverResources
   */
  readonly moverResources?: ReplicationDestinationSpecRcloneMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationDestinationSpecRclone#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationDestinationSpecRcloneMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationDestinationSpecRclone#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * RcloneConfig is the rclone secret name
   *
   * @schema ReplicationDestinationSpecRclone#rcloneConfig
   */
  readonly rcloneConfig?: string;

  /**
   * RcloneConfigSection is the section in rclone_config file to use for the current job.
   *
   * @schema ReplicationDestinationSpecRclone#rcloneConfigSection
   */
  readonly rcloneConfigSection?: string;

  /**
   * RcloneDestPath is the remote path to sync to.
   *
   * @schema ReplicationDestinationSpecRclone#rcloneDestPath
   */
  readonly rcloneDestPath?: string;

  /**
   * storageClassName can be used to specify the StorageClass of the
   * destination volume. If not set, the default StorageClass will be used.
   *
   * @schema ReplicationDestinationSpecRclone#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationDestinationSpecRclone#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRclone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRclone(
  obj: ReplicationDestinationSpecRclone | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "customCA": toJson_ReplicationDestinationSpecRcloneCustomCa(obj.customCa),
    "destinationPVC": obj.destinationPvc,
    "moverAffinity": toJson_ReplicationDestinationSpecRcloneMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationDestinationSpecRcloneMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationDestinationSpecRcloneMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "rcloneConfig": obj.rcloneConfig,
    "rcloneConfigSection": obj.rcloneConfigSection,
    "rcloneDestPath": obj.rcloneDestPath,
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * restic defines the configuration when using Restic-based replication.
 *
 * @schema ReplicationDestinationSpecRestic
 */
export interface ReplicationDestinationSpecRestic {
  /**
   * accessModes specifies the access modes for the destination volume.
   *
   * @schema ReplicationDestinationSpecRestic#accessModes
   */
  readonly accessModes?: string[];

  /**
   * accessModes can be used to set the accessModes of restic metadata cache volume
   *
   * @schema ReplicationDestinationSpecRestic#cacheAccessModes
   */
  readonly cacheAccessModes?: string[];

  /**
   * cacheCapacity can be used to set the size of the restic metadata cache volume
   *
   * @schema ReplicationDestinationSpecRestic#cacheCapacity
   */
  readonly cacheCapacity?: ReplicationDestinationSpecResticCacheCapacity;

  /**
   * cacheStorageClassName can be used to set the StorageClass of the restic
   * metadata cache volume
   *
   * @schema ReplicationDestinationSpecRestic#cacheStorageClassName
   */
  readonly cacheStorageClassName?: string;

  /**
   * capacity is the size of the destination volume to create.
   *
   * @schema ReplicationDestinationSpecRestic#capacity
   */
  readonly capacity?: ReplicationDestinationSpecResticCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the destination
   * volume should be created.
   *
   * @schema ReplicationDestinationSpecRestic#copyMethod
   */
  readonly copyMethod?: ReplicationDestinationSpecResticCopyMethod;

  /**
   * customCA is a custom CA that will be used to verify the remote
   *
   * @schema ReplicationDestinationSpecRestic#customCA
   */
  readonly customCa?: ReplicationDestinationSpecResticCustomCa;

  /**
   * destinationPVC is a PVC to use as the transfer destination instead of
   * automatically provisioning one. Either this field or both capacity and
   * accessModes must be specified.
   *
   * @schema ReplicationDestinationSpecRestic#destinationPVC
   */
  readonly destinationPvc?: string;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationDestinationSpecRestic#moverAffinity
   */
  readonly moverAffinity?: ReplicationDestinationSpecResticMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationDestinationSpecRestic#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationDestinationSpecRestic#moverResources
   */
  readonly moverResources?: ReplicationDestinationSpecResticMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationDestinationSpecRestic#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationDestinationSpecResticMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationDestinationSpecRestic#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * Previous specifies the number of image to skip before selecting one to restore from
   *
   * @schema ReplicationDestinationSpecRestic#previous
   */
  readonly previous?: number;

  /**
   * Repository is the secret name containing repository info
   *
   * @schema ReplicationDestinationSpecRestic#repository
   */
  readonly repository?: string;

  /**
   * RestoreAsOf refers to the backup that is most recent as of that time.
   *
   * @schema ReplicationDestinationSpecRestic#restoreAsOf
   */
  readonly restoreAsOf?: Date;

  /**
   * storageClassName can be used to specify the StorageClass of the
   * destination volume. If not set, the default StorageClass will be used.
   *
   * @schema ReplicationDestinationSpecRestic#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationDestinationSpecRestic#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRestic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRestic(
  obj: ReplicationDestinationSpecRestic | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "cacheAccessModes": obj.cacheAccessModes?.map((y) => y),
    "cacheCapacity": obj.cacheCapacity?.value,
    "cacheStorageClassName": obj.cacheStorageClassName,
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "customCA": toJson_ReplicationDestinationSpecResticCustomCa(obj.customCa),
    "destinationPVC": obj.destinationPvc,
    "moverAffinity": toJson_ReplicationDestinationSpecResticMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationDestinationSpecResticMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationDestinationSpecResticMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "previous": obj.previous,
    "repository": obj.repository,
    "restoreAsOf": obj.restoreAsOf?.toISOString(),
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rsync defines the configuration when using Rsync-based replication.
 *
 * @schema ReplicationDestinationSpecRsync
 */
export interface ReplicationDestinationSpecRsync {
  /**
   * accessModes specifies the access modes for the destination volume.
   *
   * @schema ReplicationDestinationSpecRsync#accessModes
   */
  readonly accessModes?: string[];

  /**
   * address is the remote address to connect to for replication.
   *
   * @schema ReplicationDestinationSpecRsync#address
   */
  readonly address?: string;

  /**
   * capacity is the size of the destination volume to create.
   *
   * @schema ReplicationDestinationSpecRsync#capacity
   */
  readonly capacity?: ReplicationDestinationSpecRsyncCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the destination
   * volume should be created.
   *
   * @schema ReplicationDestinationSpecRsync#copyMethod
   */
  readonly copyMethod?: ReplicationDestinationSpecRsyncCopyMethod;

  /**
   * destinationPVC is a PVC to use as the transfer destination instead of
   * automatically provisioning one. Either this field or both capacity and
   * accessModes must be specified.
   *
   * @schema ReplicationDestinationSpecRsync#destinationPVC
   */
  readonly destinationPvc?: string;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationDestinationSpecRsync#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationDestinationSpecRsync#moverResources
   */
  readonly moverResources?: ReplicationDestinationSpecRsyncMoverResources;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as the ReplicationDestination.
   *
   * @schema ReplicationDestinationSpecRsync#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * path is the remote path to rsync from. Defaults to "/"
   *
   * @default "
   * @schema ReplicationDestinationSpecRsync#path
   */
  readonly path?: string;

  /**
   * port is the SSH port to connect to for replication. Defaults to 22.
   *
   * @default 22.
   * @schema ReplicationDestinationSpecRsync#port
   */
  readonly port?: number;

  /**
   * serviceAnnotations defines annotations that will be added to the
   * service created for incoming SSH connections.  If set, these annotations
   * will be used instead of any VolSync default values.
   *
   * @schema ReplicationDestinationSpecRsync#serviceAnnotations
   */
  readonly serviceAnnotations?: { [key: string]: string };

  /**
   * serviceType determines the Service type that will be created for incoming
   * SSH connections.
   *
   * @schema ReplicationDestinationSpecRsync#serviceType
   */
  readonly serviceType?: string;

  /**
   * sshKeys is the name of a Secret that contains the SSH keys to be used for
   * authentication. If not provided, the keys will be generated.
   *
   * @schema ReplicationDestinationSpecRsync#sshKeys
   */
  readonly sshKeys?: string;

  /**
   * sshUser is the username for outgoing SSH connections. Defaults to "root".
   *
   * @default root".
   * @schema ReplicationDestinationSpecRsync#sshUser
   */
  readonly sshUser?: string;

  /**
   * storageClassName can be used to specify the StorageClass of the
   * destination volume. If not set, the default StorageClass will be used.
   *
   * @schema ReplicationDestinationSpecRsync#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationDestinationSpecRsync#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsync' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsync(
  obj: ReplicationDestinationSpecRsync | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "address": obj.address,
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "destinationPVC": obj.destinationPvc,
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationDestinationSpecRsyncMoverResources(
      obj.moverResources,
    ),
    "moverServiceAccount": obj.moverServiceAccount,
    "path": obj.path,
    "port": obj.port,
    "serviceAnnotations": ((obj.serviceAnnotations) === undefined)
      ? undefined
      : (Object.entries(obj.serviceAnnotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "serviceType": obj.serviceType,
    "sshKeys": obj.sshKeys,
    "sshUser": obj.sshUser,
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rsyncTLS defines the configuration when using Rsync-based replication over TLS.
 *
 * @schema ReplicationDestinationSpecRsyncTls
 */
export interface ReplicationDestinationSpecRsyncTls {
  /**
   * accessModes specifies the access modes for the destination volume.
   *
   * @schema ReplicationDestinationSpecRsyncTls#accessModes
   */
  readonly accessModes?: string[];

  /**
   * capacity is the size of the destination volume to create.
   *
   * @schema ReplicationDestinationSpecRsyncTls#capacity
   */
  readonly capacity?: ReplicationDestinationSpecRsyncTlsCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the destination
   * volume should be created.
   *
   * @schema ReplicationDestinationSpecRsyncTls#copyMethod
   */
  readonly copyMethod?: ReplicationDestinationSpecRsyncTlsCopyMethod;

  /**
   * destinationPVC is a PVC to use as the transfer destination instead of
   * automatically provisioning one. Either this field or both capacity and
   * accessModes must be specified.
   *
   * @schema ReplicationDestinationSpecRsyncTls#destinationPVC
   */
  readonly destinationPvc?: string;

  /**
   * keySecret is the name of a Secret that contains the TLS pre-shared key to
   * be used for authentication. If not provided, the key will be generated.
   *
   * @schema ReplicationDestinationSpecRsyncTls#keySecret
   */
  readonly keySecret?: string;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationDestinationSpecRsyncTls#moverAffinity
   */
  readonly moverAffinity?: ReplicationDestinationSpecRsyncTlsMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationDestinationSpecRsyncTls#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationDestinationSpecRsyncTls#moverResources
   */
  readonly moverResources?: ReplicationDestinationSpecRsyncTlsMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationDestinationSpecRsyncTls#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationDestinationSpecRsyncTlsMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationDestinationSpecRsyncTls#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * serviceAnnotations defines annotations that will be added to the
   * service created for incoming SSH connections.  If set, these annotations
   * will be used instead of any VolSync default values.
   *
   * @schema ReplicationDestinationSpecRsyncTls#serviceAnnotations
   */
  readonly serviceAnnotations?: { [key: string]: string };

  /**
   * serviceType determines the Service type that will be created for incoming
   * TLS connections.
   *
   * @schema ReplicationDestinationSpecRsyncTls#serviceType
   */
  readonly serviceType?: string;

  /**
   * storageClassName can be used to specify the StorageClass of the
   * destination volume. If not set, the default StorageClass will be used.
   *
   * @schema ReplicationDestinationSpecRsyncTls#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationDestinationSpecRsyncTls#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTls(
  obj: ReplicationDestinationSpecRsyncTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "destinationPVC": obj.destinationPvc,
    "keySecret": obj.keySecret,
    "moverAffinity": toJson_ReplicationDestinationSpecRsyncTlsMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationDestinationSpecRsyncTlsMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "serviceAnnotations": ((obj.serviceAnnotations) === undefined)
      ? undefined
      : (Object.entries(obj.serviceAnnotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "serviceType": obj.serviceType,
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * trigger determines if/when the destination should attempt to synchronize
 * data with the source.
 *
 * @schema ReplicationDestinationSpecTrigger
 */
export interface ReplicationDestinationSpecTrigger {
  /**
   * manual is a string value that schedules a manual trigger.
   * Once a sync completes then status.lastManualSync is set to the same string value.
   * A consumer of a manual trigger should set spec.trigger.manual to a known value
   * and then wait for lastManualSync to be updated by the operator to the same value,
   * which means that the manual trigger will then pause and wait for further
   * updates to the trigger.
   *
   * @schema ReplicationDestinationSpecTrigger#manual
   */
  readonly manual?: string;

  /**
   * schedule is a cronspec (https://en.wikipedia.org/wiki/Cron#Overview) that
   * can be used to schedule replication to occur at regular, time-based
   * intervals.
   * nolint:lll
   *
   * @schema ReplicationDestinationSpecTrigger#schedule
   */
  readonly schedule?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecTrigger(
  obj: ReplicationDestinationSpecTrigger | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "manual": obj.manual,
    "schedule": obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * capacity is the size of the destination volume to create.
 *
 * @schema ReplicationDestinationSpecRcloneCapacity
 */
export class ReplicationDestinationSpecRcloneCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRcloneCapacity {
    return new ReplicationDestinationSpecRcloneCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRcloneCapacity {
    return new ReplicationDestinationSpecRcloneCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the destination
 * volume should be created.
 *
 * @schema ReplicationDestinationSpecRcloneCopyMethod
 */
export enum ReplicationDestinationSpecRcloneCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * customCA is a custom CA that will be used to verify the remote
 *
 * @schema ReplicationDestinationSpecRcloneCustomCa
 */
export interface ReplicationDestinationSpecRcloneCustomCa {
  /**
   * The name of a ConfigMap that contains the custom CA certificate
   * If ConfigMapName is used then SecretName should not be set
   *
   * @schema ReplicationDestinationSpecRcloneCustomCa#configMapName
   */
  readonly configMapName?: string;

  /**
   * The key within the Secret or ConfigMap containing the CA certificate
   *
   * @schema ReplicationDestinationSpecRcloneCustomCa#key
   */
  readonly key?: string;

  /**
   * The name of a Secret that contains the custom CA certificate
   * If SecretName is used then ConfigMapName should not be set
   *
   * @schema ReplicationDestinationSpecRcloneCustomCa#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneCustomCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneCustomCa(
  obj: ReplicationDestinationSpecRcloneCustomCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapName": obj.configMapName,
    "key": obj.key,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinity
 */
export interface ReplicationDestinationSpecRcloneMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinity#podAffinity
   */
  readonly podAffinity?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinity(
  obj: ReplicationDestinationSpecRcloneMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity(
        obj.nodeAffinity,
      ),
    "podAffinity":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinity(
        obj.podAffinity,
      ),
    "podAntiAffinity":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationDestinationSpecRcloneMoverResources
 */
export interface ReplicationDestinationSpecRcloneMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationDestinationSpecRcloneMoverResources#claims
   */
  readonly claims?: ReplicationDestinationSpecRcloneMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecRcloneMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationDestinationSpecRcloneMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecRcloneMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationDestinationSpecRcloneMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverResources(
  obj: ReplicationDestinationSpecRcloneMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationDestinationSpecRcloneMoverSecurityContext
 */
export interface ReplicationDestinationSpecRcloneMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#sysctls
   */
  readonly sysctls?:
    ReplicationDestinationSpecRcloneMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverSecurityContext(
  obj: ReplicationDestinationSpecRcloneMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cacheCapacity can be used to set the size of the restic metadata cache volume
 *
 * @schema ReplicationDestinationSpecResticCacheCapacity
 */
export class ReplicationDestinationSpecResticCacheCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecResticCacheCapacity {
    return new ReplicationDestinationSpecResticCacheCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecResticCacheCapacity {
    return new ReplicationDestinationSpecResticCacheCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * capacity is the size of the destination volume to create.
 *
 * @schema ReplicationDestinationSpecResticCapacity
 */
export class ReplicationDestinationSpecResticCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecResticCapacity {
    return new ReplicationDestinationSpecResticCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecResticCapacity {
    return new ReplicationDestinationSpecResticCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the destination
 * volume should be created.
 *
 * @schema ReplicationDestinationSpecResticCopyMethod
 */
export enum ReplicationDestinationSpecResticCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * customCA is a custom CA that will be used to verify the remote
 *
 * @schema ReplicationDestinationSpecResticCustomCa
 */
export interface ReplicationDestinationSpecResticCustomCa {
  /**
   * The name of a ConfigMap that contains the custom CA certificate
   * If ConfigMapName is used then SecretName should not be set
   *
   * @schema ReplicationDestinationSpecResticCustomCa#configMapName
   */
  readonly configMapName?: string;

  /**
   * The key within the Secret or ConfigMap containing the CA certificate
   *
   * @schema ReplicationDestinationSpecResticCustomCa#key
   */
  readonly key?: string;

  /**
   * The name of a Secret that contains the custom CA certificate
   * If SecretName is used then ConfigMapName should not be set
   *
   * @schema ReplicationDestinationSpecResticCustomCa#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticCustomCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticCustomCa(
  obj: ReplicationDestinationSpecResticCustomCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapName": obj.configMapName,
    "key": obj.key,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationDestinationSpecResticMoverAffinity
 */
export interface ReplicationDestinationSpecResticMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationDestinationSpecResticMoverAffinity#podAffinity
   */
  readonly podAffinity?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationDestinationSpecResticMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinity(
  obj: ReplicationDestinationSpecResticMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity":
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinity(
        obj.nodeAffinity,
      ),
    "podAffinity":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinity(
        obj.podAffinity,
      ),
    "podAntiAffinity":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationDestinationSpecResticMoverResources
 */
export interface ReplicationDestinationSpecResticMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationDestinationSpecResticMoverResources#claims
   */
  readonly claims?: ReplicationDestinationSpecResticMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecResticMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationDestinationSpecResticMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecResticMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationDestinationSpecResticMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverResources(
  obj: ReplicationDestinationSpecResticMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationDestinationSpecResticMoverSecurityContext
 */
export interface ReplicationDestinationSpecResticMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#sysctls
   */
  readonly sysctls?:
    ReplicationDestinationSpecResticMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverSecurityContext(
  obj: ReplicationDestinationSpecResticMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * capacity is the size of the destination volume to create.
 *
 * @schema ReplicationDestinationSpecRsyncCapacity
 */
export class ReplicationDestinationSpecRsyncCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRsyncCapacity {
    return new ReplicationDestinationSpecRsyncCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRsyncCapacity {
    return new ReplicationDestinationSpecRsyncCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the destination
 * volume should be created.
 *
 * @schema ReplicationDestinationSpecRsyncCopyMethod
 */
export enum ReplicationDestinationSpecRsyncCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationDestinationSpecRsyncMoverResources
 */
export interface ReplicationDestinationSpecRsyncMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationDestinationSpecRsyncMoverResources#claims
   */
  readonly claims?: ReplicationDestinationSpecRsyncMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecRsyncMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationDestinationSpecRsyncMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecRsyncMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationDestinationSpecRsyncMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncMoverResources(
  obj: ReplicationDestinationSpecRsyncMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * capacity is the size of the destination volume to create.
 *
 * @schema ReplicationDestinationSpecRsyncTlsCapacity
 */
export class ReplicationDestinationSpecRsyncTlsCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRsyncTlsCapacity {
    return new ReplicationDestinationSpecRsyncTlsCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRsyncTlsCapacity {
    return new ReplicationDestinationSpecRsyncTlsCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the destination
 * volume should be created.
 *
 * @schema ReplicationDestinationSpecRsyncTlsCopyMethod
 */
export enum ReplicationDestinationSpecRsyncTlsCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinity
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinity#podAffinity
   */
  readonly podAffinity?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinity(
  obj: ReplicationDestinationSpecRsyncTlsMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity(
        obj.nodeAffinity,
      ),
    "podAffinity":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity(
        obj.podAffinity,
      ),
    "podAntiAffinity":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverResources
 */
export interface ReplicationDestinationSpecRsyncTlsMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverResources#claims
   */
  readonly claims?: ReplicationDestinationSpecRsyncTlsMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationDestinationSpecRsyncTlsMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationDestinationSpecRsyncTlsMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverResources(
  obj: ReplicationDestinationSpecRsyncTlsMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext
 */
export interface ReplicationDestinationSpecRsyncTlsMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#sysctls
   */
  readonly sysctls?:
    ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContext(
  obj: ReplicationDestinationSpecRsyncTlsMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity(
  obj: ReplicationDestinationSpecRcloneMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinity
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinity(
  obj: ReplicationDestinationSpecRcloneMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity(
  obj: ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationDestinationSpecRcloneMoverResourcesClaims
 */
export interface ReplicationDestinationSpecRcloneMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationDestinationSpecRcloneMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverResourcesClaims(
  obj: ReplicationDestinationSpecRcloneMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationDestinationSpecRcloneMoverResourcesLimits
 */
export class ReplicationDestinationSpecRcloneMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRcloneMoverResourcesLimits {
    return new ReplicationDestinationSpecRcloneMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRcloneMoverResourcesLimits {
    return new ReplicationDestinationSpecRcloneMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationDestinationSpecRcloneMoverResourcesRequests
 */
export class ReplicationDestinationSpecRcloneMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRcloneMoverResourcesRequests {
    return new ReplicationDestinationSpecRcloneMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRcloneMoverResourcesRequests {
    return new ReplicationDestinationSpecRcloneMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile
 */
export interface ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationDestinationSpecRcloneMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationDestinationSpecRcloneMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile
 */
export interface ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationDestinationSpecRcloneMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSysctls
 */
export interface ReplicationDestinationSpecRcloneMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverSecurityContextSysctls(
  obj: ReplicationDestinationSpecRcloneMoverSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions
 */
export interface ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationDestinationSpecRcloneMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinity
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinity(
  obj: ReplicationDestinationSpecResticMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinity
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinity(
  obj: ReplicationDestinationSpecResticMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity(
  obj: ReplicationDestinationSpecResticMoverAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationDestinationSpecResticMoverResourcesClaims
 */
export interface ReplicationDestinationSpecResticMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationDestinationSpecResticMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverResourcesClaims(
  obj: ReplicationDestinationSpecResticMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationDestinationSpecResticMoverResourcesLimits
 */
export class ReplicationDestinationSpecResticMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecResticMoverResourcesLimits {
    return new ReplicationDestinationSpecResticMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecResticMoverResourcesLimits {
    return new ReplicationDestinationSpecResticMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationDestinationSpecResticMoverResourcesRequests
 */
export class ReplicationDestinationSpecResticMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecResticMoverResourcesRequests {
    return new ReplicationDestinationSpecResticMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecResticMoverResourcesRequests {
    return new ReplicationDestinationSpecResticMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile
 */
export interface ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationDestinationSpecResticMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationDestinationSpecResticMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile
 */
export interface ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationDestinationSpecResticMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationDestinationSpecResticMoverSecurityContextSysctls
 */
export interface ReplicationDestinationSpecResticMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverSecurityContextSysctls(
  obj: ReplicationDestinationSpecResticMoverSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions
 */
export interface ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationDestinationSpecResticMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationDestinationSpecRsyncMoverResourcesClaims
 */
export interface ReplicationDestinationSpecRsyncMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationDestinationSpecRsyncMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncMoverResourcesClaims(
  obj: ReplicationDestinationSpecRsyncMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationDestinationSpecRsyncMoverResourcesLimits
 */
export class ReplicationDestinationSpecRsyncMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRsyncMoverResourcesLimits {
    return new ReplicationDestinationSpecRsyncMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRsyncMoverResourcesLimits {
    return new ReplicationDestinationSpecRsyncMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationDestinationSpecRsyncMoverResourcesRequests
 */
export class ReplicationDestinationSpecRsyncMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRsyncMoverResourcesRequests {
    return new ReplicationDestinationSpecRsyncMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRsyncMoverResourcesRequests {
    return new ReplicationDestinationSpecRsyncMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity(
  obj: ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity(
  obj: ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinity
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverResourcesClaims
 */
export interface ReplicationDestinationSpecRsyncTlsMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverResourcesClaims(
  obj: ReplicationDestinationSpecRsyncTlsMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationDestinationSpecRsyncTlsMoverResourcesLimits
 */
export class ReplicationDestinationSpecRsyncTlsMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRsyncTlsMoverResourcesLimits {
    return new ReplicationDestinationSpecRsyncTlsMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRsyncTlsMoverResourcesLimits {
    return new ReplicationDestinationSpecRsyncTlsMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationDestinationSpecRsyncTlsMoverResourcesRequests
 */
export class ReplicationDestinationSpecRsyncTlsMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationDestinationSpecRsyncTlsMoverResourcesRequests {
    return new ReplicationDestinationSpecRsyncTlsMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationDestinationSpecRsyncTlsMoverResourcesRequests {
    return new ReplicationDestinationSpecRsyncTlsMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile
 */
export interface ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile
 */
export interface ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls
 */
export interface ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverSecurityContextSysctls
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationDestinationSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A ReplicationSource is a VolSync resource that you can use to define the source PVC and replication mover type,
enabling you to replicate or synchronize PVC data to a remote location.
 *
 * @schema ReplicationSource
 */
export class ReplicationSource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationSource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "volsync.backube/v1alpha1",
    kind: "ReplicationSource",
  };

  /**
   * Renders a Kubernetes manifest for "ReplicationSource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationSourceProps = {}): any {
    return {
      ...ReplicationSource.GVK,
      ...toJson_ReplicationSourceProps(props),
    };
  }

  /**
   * Defines a "ReplicationSource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ReplicationSourceProps = {},
  ) {
    super(scope, id, {
      ...ReplicationSource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationSource.GVK,
      ...toJson_ReplicationSourceProps(resolved),
    };
  }
}

/**
 * A ReplicationSource is a VolSync resource that you can use to define the source PVC and replication mover type,
 * enabling you to replicate or synchronize PVC data to a remote location.
 *
 * @schema ReplicationSource
 */
export interface ReplicationSourceProps {
  /**
   * @schema ReplicationSource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * spec is the desired state of the ReplicationSource, including the
   * replication method to use and its configuration.
   *
   * @schema ReplicationSource#spec
   */
  readonly spec?: ReplicationSourceSpec;
}

/**
 * Converts an object of type 'ReplicationSourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceProps(
  obj: ReplicationSourceProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ReplicationSourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * spec is the desired state of the ReplicationSource, including the
 * replication method to use and its configuration.
 *
 * @schema ReplicationSourceSpec
 */
export interface ReplicationSourceSpec {
  /**
   * external defines the configuration when using an external replication
   * provider.
   *
   * @schema ReplicationSourceSpec#external
   */
  readonly external?: ReplicationSourceSpecExternal;

  /**
   * paused can be used to temporarily stop replication. Defaults to "false".
   *
   * @default false".
   * @schema ReplicationSourceSpec#paused
   */
  readonly paused?: boolean;

  /**
   * rclone defines the configuration when using Rclone-based replication.
   *
   * @schema ReplicationSourceSpec#rclone
   */
  readonly rclone?: ReplicationSourceSpecRclone;

  /**
   * restic defines the configuration when using Restic-based replication.
   *
   * @schema ReplicationSourceSpec#restic
   */
  readonly restic?: ReplicationSourceSpecRestic;

  /**
   * rsync defines the configuration when using Rsync-based replication.
   *
   * @schema ReplicationSourceSpec#rsync
   */
  readonly rsync?: ReplicationSourceSpecRsync;

  /**
   * rsyncTLS defines the configuration when using Rsync-based replication over TLS.
   *
   * @schema ReplicationSourceSpec#rsyncTLS
   */
  readonly rsyncTls?: ReplicationSourceSpecRsyncTls;

  /**
   * sourcePVC is the name of the PersistentVolumeClaim (PVC) to replicate.
   *
   * @schema ReplicationSourceSpec#sourcePVC
   */
  readonly sourcePvc?: string;

  /**
   * syncthing defines the configuration when using Syncthing-based replication.
   *
   * @schema ReplicationSourceSpec#syncthing
   */
  readonly syncthing?: ReplicationSourceSpecSyncthing;

  /**
   * trigger determines when the latest state of the volume will be captured
   * (and potentially replicated to the destination).
   *
   * @schema ReplicationSourceSpec#trigger
   */
  readonly trigger?: ReplicationSourceSpecTrigger;
}

/**
 * Converts an object of type 'ReplicationSourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpec(
  obj: ReplicationSourceSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "external": toJson_ReplicationSourceSpecExternal(obj.external),
    "paused": obj.paused,
    "rclone": toJson_ReplicationSourceSpecRclone(obj.rclone),
    "restic": toJson_ReplicationSourceSpecRestic(obj.restic),
    "rsync": toJson_ReplicationSourceSpecRsync(obj.rsync),
    "rsyncTLS": toJson_ReplicationSourceSpecRsyncTls(obj.rsyncTls),
    "sourcePVC": obj.sourcePvc,
    "syncthing": toJson_ReplicationSourceSpecSyncthing(obj.syncthing),
    "trigger": toJson_ReplicationSourceSpecTrigger(obj.trigger),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * external defines the configuration when using an external replication
 * provider.
 *
 * @schema ReplicationSourceSpecExternal
 */
export interface ReplicationSourceSpecExternal {
  /**
   * parameters are provider-specific key/value configuration parameters. For
   * more information, please see the documentation of the specific
   * replication provider being used.
   *
   * @schema ReplicationSourceSpecExternal#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * provider is the name of the external replication provider. The name
   * should be of the form: domain.com/provider.
   *
   * @schema ReplicationSourceSpecExternal#provider
   */
  readonly provider?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecExternal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecExternal(
  obj: ReplicationSourceSpecExternal | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "parameters": ((obj.parameters) === undefined)
      ? undefined
      : (Object.entries(obj.parameters).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "provider": obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rclone defines the configuration when using Rclone-based replication.
 *
 * @schema ReplicationSourceSpecRclone
 */
export interface ReplicationSourceSpecRclone {
  /**
   * accessModes can be used to override the accessModes of the PiT image.
   *
   * @schema ReplicationSourceSpecRclone#accessModes
   */
  readonly accessModes?: string[];

  /**
   * capacity can be used to override the capacity of the PiT image.
   *
   * @schema ReplicationSourceSpecRclone#capacity
   */
  readonly capacity?: ReplicationSourceSpecRcloneCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the source volume
   * should be created.
   *
   * @schema ReplicationSourceSpecRclone#copyMethod
   */
  readonly copyMethod?: ReplicationSourceSpecRcloneCopyMethod;

  /**
   * customCA is a custom CA that will be used to verify the remote
   *
   * @schema ReplicationSourceSpecRclone#customCA
   */
  readonly customCa?: ReplicationSourceSpecRcloneCustomCa;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationSourceSpecRclone#moverAffinity
   */
  readonly moverAffinity?: ReplicationSourceSpecRcloneMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationSourceSpecRclone#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationSourceSpecRclone#moverResources
   */
  readonly moverResources?: ReplicationSourceSpecRcloneMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationSourceSpecRclone#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationSourceSpecRcloneMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationSourceSpecRclone#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * RcloneConfig is the rclone secret name
   *
   * @schema ReplicationSourceSpecRclone#rcloneConfig
   */
  readonly rcloneConfig?: string;

  /**
   * RcloneConfigSection is the section in rclone_config file to use for the current job.
   *
   * @schema ReplicationSourceSpecRclone#rcloneConfigSection
   */
  readonly rcloneConfigSection?: string;

  /**
   * RcloneDestPath is the remote path to sync to.
   *
   * @schema ReplicationSourceSpecRclone#rcloneDestPath
   */
  readonly rcloneDestPath?: string;

  /**
   * storageClassName can be used to override the StorageClass of the PiT
   * image.
   *
   * @schema ReplicationSourceSpecRclone#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationSourceSpecRclone#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRclone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRclone(
  obj: ReplicationSourceSpecRclone | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "customCA": toJson_ReplicationSourceSpecRcloneCustomCa(obj.customCa),
    "moverAffinity": toJson_ReplicationSourceSpecRcloneMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationSourceSpecRcloneMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationSourceSpecRcloneMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "rcloneConfig": obj.rcloneConfig,
    "rcloneConfigSection": obj.rcloneConfigSection,
    "rcloneDestPath": obj.rcloneDestPath,
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * restic defines the configuration when using Restic-based replication.
 *
 * @schema ReplicationSourceSpecRestic
 */
export interface ReplicationSourceSpecRestic {
  /**
   * accessModes can be used to override the accessModes of the PiT image.
   *
   * @schema ReplicationSourceSpecRestic#accessModes
   */
  readonly accessModes?: string[];

  /**
   * CacheAccessModes can be used to set the accessModes of restic metadata cache volume
   *
   * @schema ReplicationSourceSpecRestic#cacheAccessModes
   */
  readonly cacheAccessModes?: string[];

  /**
   * cacheCapacity can be used to set the size of the restic metadata cache volume
   *
   * @schema ReplicationSourceSpecRestic#cacheCapacity
   */
  readonly cacheCapacity?: ReplicationSourceSpecResticCacheCapacity;

  /**
   * cacheStorageClassName can be used to set the StorageClass of the restic
   * metadata cache volume
   *
   * @schema ReplicationSourceSpecRestic#cacheStorageClassName
   */
  readonly cacheStorageClassName?: string;

  /**
   * capacity can be used to override the capacity of the PiT image.
   *
   * @schema ReplicationSourceSpecRestic#capacity
   */
  readonly capacity?: ReplicationSourceSpecResticCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the source volume
   * should be created.
   *
   * @schema ReplicationSourceSpecRestic#copyMethod
   */
  readonly copyMethod?: ReplicationSourceSpecResticCopyMethod;

  /**
   * customCA is a custom CA that will be used to verify the remote
   *
   * @schema ReplicationSourceSpecRestic#customCA
   */
  readonly customCa?: ReplicationSourceSpecResticCustomCa;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationSourceSpecRestic#moverAffinity
   */
  readonly moverAffinity?: ReplicationSourceSpecResticMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationSourceSpecRestic#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationSourceSpecRestic#moverResources
   */
  readonly moverResources?: ReplicationSourceSpecResticMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationSourceSpecRestic#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationSourceSpecResticMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationSourceSpecRestic#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * PruneIntervalDays define how often to prune the repository
   *
   * @schema ReplicationSourceSpecRestic#pruneIntervalDays
   */
  readonly pruneIntervalDays?: number;

  /**
   * Repository is the secret name containing repository info
   *
   * @schema ReplicationSourceSpecRestic#repository
   */
  readonly repository?: string;

  /**
   * ResticRetainPolicy define the retain policy
   *
   * @schema ReplicationSourceSpecRestic#retain
   */
  readonly retain?: ReplicationSourceSpecResticRetain;

  /**
   * storageClassName can be used to override the StorageClass of the PiT
   * image.
   *
   * @schema ReplicationSourceSpecRestic#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * unlock is a string value that schedules an unlock on the restic repository during
   * the next sync operation.
   * Once a sync completes then status.restic.lastUnlocked is set to the same string value.
   * To unlock a repository, set spec.restic.unlock to a known value and then wait for
   * lastUnlocked to be updated by the operator to the same value,
   * which means that the sync unlocked the repository by running a restic unlock command and
   * then ran a backup.
   * Unlock will not be run again unless spec.restic.unlock is set to a different value.
   *
   * @schema ReplicationSourceSpecRestic#unlock
   */
  readonly unlock?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationSourceSpecRestic#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRestic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRestic(
  obj: ReplicationSourceSpecRestic | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "cacheAccessModes": obj.cacheAccessModes?.map((y) => y),
    "cacheCapacity": obj.cacheCapacity?.value,
    "cacheStorageClassName": obj.cacheStorageClassName,
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "customCA": toJson_ReplicationSourceSpecResticCustomCa(obj.customCa),
    "moverAffinity": toJson_ReplicationSourceSpecResticMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationSourceSpecResticMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationSourceSpecResticMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "pruneIntervalDays": obj.pruneIntervalDays,
    "repository": obj.repository,
    "retain": toJson_ReplicationSourceSpecResticRetain(obj.retain),
    "storageClassName": obj.storageClassName,
    "unlock": obj.unlock,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rsync defines the configuration when using Rsync-based replication.
 *
 * @schema ReplicationSourceSpecRsync
 */
export interface ReplicationSourceSpecRsync {
  /**
   * accessModes can be used to override the accessModes of the PiT image.
   *
   * @schema ReplicationSourceSpecRsync#accessModes
   */
  readonly accessModes?: string[];

  /**
   * address is the remote address to connect to for replication.
   *
   * @schema ReplicationSourceSpecRsync#address
   */
  readonly address?: string;

  /**
   * capacity can be used to override the capacity of the PiT image.
   *
   * @schema ReplicationSourceSpecRsync#capacity
   */
  readonly capacity?: ReplicationSourceSpecRsyncCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the source volume
   * should be created.
   *
   * @schema ReplicationSourceSpecRsync#copyMethod
   */
  readonly copyMethod?: ReplicationSourceSpecRsyncCopyMethod;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationSourceSpecRsync#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationSourceSpecRsync#moverResources
   */
  readonly moverResources?: ReplicationSourceSpecRsyncMoverResources;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as the ReplicationSource.
   *
   * @schema ReplicationSourceSpecRsync#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * path is the remote path to rsync to. Defaults to "/"
   *
   * @default "
   * @schema ReplicationSourceSpecRsync#path
   */
  readonly path?: string;

  /**
   * port is the SSH port to connect to for replication. Defaults to 22.
   *
   * @default 22.
   * @schema ReplicationSourceSpecRsync#port
   */
  readonly port?: number;

  /**
   * serviceType determines the Service type that will be created for incoming
   * SSH connections.
   *
   * @schema ReplicationSourceSpecRsync#serviceType
   */
  readonly serviceType?: string;

  /**
   * sshKeys is the name of a Secret that contains the SSH keys to be used for
   * authentication. If not provided, the keys will be generated.
   *
   * @schema ReplicationSourceSpecRsync#sshKeys
   */
  readonly sshKeys?: string;

  /**
   * sshUser is the username for outgoing SSH connections. Defaults to "root".
   *
   * @default root".
   * @schema ReplicationSourceSpecRsync#sshUser
   */
  readonly sshUser?: string;

  /**
   * storageClassName can be used to override the StorageClass of the PiT
   * image.
   *
   * @schema ReplicationSourceSpecRsync#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationSourceSpecRsync#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsync' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsync(
  obj: ReplicationSourceSpecRsync | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "address": obj.address,
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationSourceSpecRsyncMoverResources(
      obj.moverResources,
    ),
    "moverServiceAccount": obj.moverServiceAccount,
    "path": obj.path,
    "port": obj.port,
    "serviceType": obj.serviceType,
    "sshKeys": obj.sshKeys,
    "sshUser": obj.sshUser,
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rsyncTLS defines the configuration when using Rsync-based replication over TLS.
 *
 * @schema ReplicationSourceSpecRsyncTls
 */
export interface ReplicationSourceSpecRsyncTls {
  /**
   * accessModes can be used to override the accessModes of the PiT image.
   *
   * @schema ReplicationSourceSpecRsyncTls#accessModes
   */
  readonly accessModes?: string[];

  /**
   * address is the remote address to connect to for replication.
   *
   * @schema ReplicationSourceSpecRsyncTls#address
   */
  readonly address?: string;

  /**
   * capacity can be used to override the capacity of the PiT image.
   *
   * @schema ReplicationSourceSpecRsyncTls#capacity
   */
  readonly capacity?: ReplicationSourceSpecRsyncTlsCapacity;

  /**
   * copyMethod describes how a point-in-time (PiT) image of the source volume
   * should be created.
   *
   * @schema ReplicationSourceSpecRsyncTls#copyMethod
   */
  readonly copyMethod?: ReplicationSourceSpecRsyncTlsCopyMethod;

  /**
   * keySecret is the name of a Secret that contains the TLS pre-shared key to
   * be used for authentication. If not provided, the key will be generated.
   *
   * @schema ReplicationSourceSpecRsyncTls#keySecret
   */
  readonly keySecret?: string;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationSourceSpecRsyncTls#moverAffinity
   */
  readonly moverAffinity?: ReplicationSourceSpecRsyncTlsMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationSourceSpecRsyncTls#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationSourceSpecRsyncTls#moverResources
   */
  readonly moverResources?: ReplicationSourceSpecRsyncTlsMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationSourceSpecRsyncTls#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationSourceSpecRsyncTlsMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationSourceSpecRsyncTls#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * port is the port to connect to for replication. Defaults to 8000.
   *
   * @default 8000.
   * @schema ReplicationSourceSpecRsyncTls#port
   */
  readonly port?: number;

  /**
   * storageClassName can be used to override the StorageClass of the PiT
   * image.
   *
   * @schema ReplicationSourceSpecRsyncTls#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeSnapshotClassName can be used to specify the VSC to be used if
   * copyMethod is Snapshot. If not set, the default VSC is used.
   *
   * @schema ReplicationSourceSpecRsyncTls#volumeSnapshotClassName
   */
  readonly volumeSnapshotClassName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTls(
  obj: ReplicationSourceSpecRsyncTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "address": obj.address,
    "capacity": obj.capacity?.value,
    "copyMethod": obj.copyMethod,
    "keySecret": obj.keySecret,
    "moverAffinity": toJson_ReplicationSourceSpecRsyncTlsMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationSourceSpecRsyncTlsMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "port": obj.port,
    "storageClassName": obj.storageClassName,
    "volumeSnapshotClassName": obj.volumeSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * syncthing defines the configuration when using Syncthing-based replication.
 *
 * @schema ReplicationSourceSpecSyncthing
 */
export interface ReplicationSourceSpecSyncthing {
  /**
   * Used to set the accessModes of Syncthing config volume.
   *
   * @schema ReplicationSourceSpecSyncthing#configAccessModes
   */
  readonly configAccessModes?: string[];

  /**
   * Used to set the size of the Syncthing config volume.
   *
   * @schema ReplicationSourceSpecSyncthing#configCapacity
   */
  readonly configCapacity?: ReplicationSourceSpecSyncthingConfigCapacity;

  /**
   * Used to set the StorageClass of the Syncthing config volume.
   *
   * @schema ReplicationSourceSpecSyncthing#configStorageClassName
   */
  readonly configStorageClassName?: string;

  /**
   * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
   *
   * @schema ReplicationSourceSpecSyncthing#moverAffinity
   */
  readonly moverAffinity?: ReplicationSourceSpecSyncthingMoverAffinity;

  /**
   * Labels that should be added to data mover pods
   * These will be in addition to any labels that VolSync may add
   *
   * @schema ReplicationSourceSpecSyncthing#moverPodLabels
   */
  readonly moverPodLabels?: { [key: string]: string };

  /**
   * Resources represents compute resources required by the data mover container.
   * Immutable.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   * This should only be used by advanced users as this can result in a mover
   * pod being unschedulable or crashing due to limited resources.
   *
   * @schema ReplicationSourceSpecSyncthing#moverResources
   */
  readonly moverResources?: ReplicationSourceSpecSyncthingMoverResources;

  /**
   * MoverSecurityContext allows specifying the PodSecurityContext that will
   * be used by the data mover
   *
   * @schema ReplicationSourceSpecSyncthing#moverSecurityContext
   */
  readonly moverSecurityContext?:
    ReplicationSourceSpecSyncthingMoverSecurityContext;

  /**
   * MoverServiceAccount allows specifying the name of the service account
   * that will be used by the data mover. This should only be used by advanced
   * users who want to override the service account normally used by the mover.
   * The service account needs to exist in the same namespace as this CR.
   *
   * @schema ReplicationSourceSpecSyncthing#moverServiceAccount
   */
  readonly moverServiceAccount?: string;

  /**
   * List of Syncthing peers to be connected for syncing
   *
   * @schema ReplicationSourceSpecSyncthing#peers
   */
  readonly peers?: ReplicationSourceSpecSyncthingPeers[];

  /**
   * Type of service to be used when exposing the Syncthing peer
   *
   * @schema ReplicationSourceSpecSyncthing#serviceType
   */
  readonly serviceType?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthing(
  obj: ReplicationSourceSpecSyncthing | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configAccessModes": obj.configAccessModes?.map((y) => y),
    "configCapacity": obj.configCapacity?.value,
    "configStorageClassName": obj.configStorageClassName,
    "moverAffinity": toJson_ReplicationSourceSpecSyncthingMoverAffinity(
      obj.moverAffinity,
    ),
    "moverPodLabels": ((obj.moverPodLabels) === undefined)
      ? undefined
      : (Object.entries(obj.moverPodLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "moverResources": toJson_ReplicationSourceSpecSyncthingMoverResources(
      obj.moverResources,
    ),
    "moverSecurityContext":
      toJson_ReplicationSourceSpecSyncthingMoverSecurityContext(
        obj.moverSecurityContext,
      ),
    "moverServiceAccount": obj.moverServiceAccount,
    "peers": obj.peers?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingPeers(y)
    ),
    "serviceType": obj.serviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * trigger determines when the latest state of the volume will be captured
 * (and potentially replicated to the destination).
 *
 * @schema ReplicationSourceSpecTrigger
 */
export interface ReplicationSourceSpecTrigger {
  /**
   * manual is a string value that schedules a manual trigger.
   * Once a sync completes then status.lastManualSync is set to the same string value.
   * A consumer of a manual trigger should set spec.trigger.manual to a known value
   * and then wait for lastManualSync to be updated by the operator to the same value,
   * which means that the manual trigger will then pause and wait for further
   * updates to the trigger.
   *
   * @schema ReplicationSourceSpecTrigger#manual
   */
  readonly manual?: string;

  /**
   * schedule is a cronspec (https://en.wikipedia.org/wiki/Cron#Overview) that
   * can be used to schedule replication to occur at regular, time-based
   * intervals.
   * nolint:lll
   *
   * @schema ReplicationSourceSpecTrigger#schedule
   */
  readonly schedule?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecTrigger(
  obj: ReplicationSourceSpecTrigger | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "manual": obj.manual,
    "schedule": obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * capacity can be used to override the capacity of the PiT image.
 *
 * @schema ReplicationSourceSpecRcloneCapacity
 */
export class ReplicationSourceSpecRcloneCapacity {
  public static fromNumber(value: number): ReplicationSourceSpecRcloneCapacity {
    return new ReplicationSourceSpecRcloneCapacity(value);
  }
  public static fromString(value: string): ReplicationSourceSpecRcloneCapacity {
    return new ReplicationSourceSpecRcloneCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the source volume
 * should be created.
 *
 * @schema ReplicationSourceSpecRcloneCopyMethod
 */
export enum ReplicationSourceSpecRcloneCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * customCA is a custom CA that will be used to verify the remote
 *
 * @schema ReplicationSourceSpecRcloneCustomCa
 */
export interface ReplicationSourceSpecRcloneCustomCa {
  /**
   * The name of a ConfigMap that contains the custom CA certificate
   * If ConfigMapName is used then SecretName should not be set
   *
   * @schema ReplicationSourceSpecRcloneCustomCa#configMapName
   */
  readonly configMapName?: string;

  /**
   * The key within the Secret or ConfigMap containing the CA certificate
   *
   * @schema ReplicationSourceSpecRcloneCustomCa#key
   */
  readonly key?: string;

  /**
   * The name of a Secret that contains the custom CA certificate
   * If SecretName is used then ConfigMapName should not be set
   *
   * @schema ReplicationSourceSpecRcloneCustomCa#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneCustomCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneCustomCa(
  obj: ReplicationSourceSpecRcloneCustomCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapName": obj.configMapName,
    "key": obj.key,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinity
 */
export interface ReplicationSourceSpecRcloneMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ReplicationSourceSpecRcloneMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinity#podAffinity
   */
  readonly podAffinity?: ReplicationSourceSpecRcloneMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinity(
  obj: ReplicationSourceSpecRcloneMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity": toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinity(
      obj.nodeAffinity,
    ),
    "podAffinity": toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinity(
      obj.podAffinity,
    ),
    "podAntiAffinity":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationSourceSpecRcloneMoverResources
 */
export interface ReplicationSourceSpecRcloneMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationSourceSpecRcloneMoverResources#claims
   */
  readonly claims?: ReplicationSourceSpecRcloneMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecRcloneMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationSourceSpecRcloneMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecRcloneMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationSourceSpecRcloneMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverResources(
  obj: ReplicationSourceSpecRcloneMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationSourceSpecRcloneMoverSecurityContext
 */
export interface ReplicationSourceSpecRcloneMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#sysctls
   */
  readonly sysctls?: ReplicationSourceSpecRcloneMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverSecurityContext(
  obj: ReplicationSourceSpecRcloneMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cacheCapacity can be used to set the size of the restic metadata cache volume
 *
 * @schema ReplicationSourceSpecResticCacheCapacity
 */
export class ReplicationSourceSpecResticCacheCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecResticCacheCapacity {
    return new ReplicationSourceSpecResticCacheCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecResticCacheCapacity {
    return new ReplicationSourceSpecResticCacheCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * capacity can be used to override the capacity of the PiT image.
 *
 * @schema ReplicationSourceSpecResticCapacity
 */
export class ReplicationSourceSpecResticCapacity {
  public static fromNumber(value: number): ReplicationSourceSpecResticCapacity {
    return new ReplicationSourceSpecResticCapacity(value);
  }
  public static fromString(value: string): ReplicationSourceSpecResticCapacity {
    return new ReplicationSourceSpecResticCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the source volume
 * should be created.
 *
 * @schema ReplicationSourceSpecResticCopyMethod
 */
export enum ReplicationSourceSpecResticCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * customCA is a custom CA that will be used to verify the remote
 *
 * @schema ReplicationSourceSpecResticCustomCa
 */
export interface ReplicationSourceSpecResticCustomCa {
  /**
   * The name of a ConfigMap that contains the custom CA certificate
   * If ConfigMapName is used then SecretName should not be set
   *
   * @schema ReplicationSourceSpecResticCustomCa#configMapName
   */
  readonly configMapName?: string;

  /**
   * The key within the Secret or ConfigMap containing the CA certificate
   *
   * @schema ReplicationSourceSpecResticCustomCa#key
   */
  readonly key?: string;

  /**
   * The name of a Secret that contains the custom CA certificate
   * If SecretName is used then ConfigMapName should not be set
   *
   * @schema ReplicationSourceSpecResticCustomCa#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticCustomCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticCustomCa(
  obj: ReplicationSourceSpecResticCustomCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapName": obj.configMapName,
    "key": obj.key,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationSourceSpecResticMoverAffinity
 */
export interface ReplicationSourceSpecResticMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationSourceSpecResticMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ReplicationSourceSpecResticMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecResticMoverAffinity#podAffinity
   */
  readonly podAffinity?: ReplicationSourceSpecResticMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecResticMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinity(
  obj: ReplicationSourceSpecResticMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity": toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinity(
      obj.nodeAffinity,
    ),
    "podAffinity": toJson_ReplicationSourceSpecResticMoverAffinityPodAffinity(
      obj.podAffinity,
    ),
    "podAntiAffinity":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationSourceSpecResticMoverResources
 */
export interface ReplicationSourceSpecResticMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationSourceSpecResticMoverResources#claims
   */
  readonly claims?: ReplicationSourceSpecResticMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecResticMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationSourceSpecResticMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecResticMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationSourceSpecResticMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverResources(
  obj: ReplicationSourceSpecResticMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationSourceSpecResticMoverSecurityContext
 */
export interface ReplicationSourceSpecResticMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecResticMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationSourceSpecResticMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#sysctls
   */
  readonly sysctls?: ReplicationSourceSpecResticMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationSourceSpecResticMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverSecurityContext(
  obj: ReplicationSourceSpecResticMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationSourceSpecResticMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationSourceSpecResticMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResticRetainPolicy define the retain policy
 *
 * @schema ReplicationSourceSpecResticRetain
 */
export interface ReplicationSourceSpecResticRetain {
  /**
   * Daily defines the number of snapshots to be kept daily
   *
   * @schema ReplicationSourceSpecResticRetain#daily
   */
  readonly daily?: number;

  /**
   * Hourly defines the number of snapshots to be kept hourly
   *
   * @schema ReplicationSourceSpecResticRetain#hourly
   */
  readonly hourly?: number;

  /**
   * Last defines the number of snapshots to be kept
   *
   * @schema ReplicationSourceSpecResticRetain#last
   */
  readonly last?: string;

  /**
   * Monthly defines the number of snapshots to be kept monthly
   *
   * @schema ReplicationSourceSpecResticRetain#monthly
   */
  readonly monthly?: number;

  /**
   * Weekly defines the number of snapshots to be kept weekly
   *
   * @schema ReplicationSourceSpecResticRetain#weekly
   */
  readonly weekly?: number;

  /**
   * Within defines the number of snapshots to be kept Within the given time period
   *
   * @schema ReplicationSourceSpecResticRetain#within
   */
  readonly within?: string;

  /**
   * Yearly defines the number of snapshots to be kept yearly
   *
   * @schema ReplicationSourceSpecResticRetain#yearly
   */
  readonly yearly?: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticRetain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticRetain(
  obj: ReplicationSourceSpecResticRetain | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "daily": obj.daily,
    "hourly": obj.hourly,
    "last": obj.last,
    "monthly": obj.monthly,
    "weekly": obj.weekly,
    "within": obj.within,
    "yearly": obj.yearly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * capacity can be used to override the capacity of the PiT image.
 *
 * @schema ReplicationSourceSpecRsyncCapacity
 */
export class ReplicationSourceSpecRsyncCapacity {
  public static fromNumber(value: number): ReplicationSourceSpecRsyncCapacity {
    return new ReplicationSourceSpecRsyncCapacity(value);
  }
  public static fromString(value: string): ReplicationSourceSpecRsyncCapacity {
    return new ReplicationSourceSpecRsyncCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the source volume
 * should be created.
 *
 * @schema ReplicationSourceSpecRsyncCopyMethod
 */
export enum ReplicationSourceSpecRsyncCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationSourceSpecRsyncMoverResources
 */
export interface ReplicationSourceSpecRsyncMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationSourceSpecRsyncMoverResources#claims
   */
  readonly claims?: ReplicationSourceSpecRsyncMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecRsyncMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationSourceSpecRsyncMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecRsyncMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationSourceSpecRsyncMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncMoverResources(
  obj: ReplicationSourceSpecRsyncMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationSourceSpecRsyncMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * capacity can be used to override the capacity of the PiT image.
 *
 * @schema ReplicationSourceSpecRsyncTlsCapacity
 */
export class ReplicationSourceSpecRsyncTlsCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRsyncTlsCapacity {
    return new ReplicationSourceSpecRsyncTlsCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRsyncTlsCapacity {
    return new ReplicationSourceSpecRsyncTlsCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * copyMethod describes how a point-in-time (PiT) image of the source volume
 * should be created.
 *
 * @schema ReplicationSourceSpecRsyncTlsCopyMethod
 */
export enum ReplicationSourceSpecRsyncTlsCopyMethod {
  /** Direct */
  DIRECT = "Direct",
  /** None */
  NONE = "None",
  /** Clone */
  CLONE = "Clone",
  /** Snapshot */
  SNAPSHOT = "Snapshot",
}

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinity
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinity#podAffinity
   */
  readonly podAffinity?: ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinity(
  obj: ReplicationSourceSpecRsyncTlsMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity(
        obj.nodeAffinity,
      ),
    "podAffinity": toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity(
      obj.podAffinity,
    ),
    "podAntiAffinity":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverResources
 */
export interface ReplicationSourceSpecRsyncTlsMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverResources#claims
   */
  readonly claims?: ReplicationSourceSpecRsyncTlsMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationSourceSpecRsyncTlsMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationSourceSpecRsyncTlsMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverResources(
  obj: ReplicationSourceSpecRsyncTlsMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext
 */
export interface ReplicationSourceSpecRsyncTlsMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#sysctls
   */
  readonly sysctls?: ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContext(
  obj: ReplicationSourceSpecRsyncTlsMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Used to set the size of the Syncthing config volume.
 *
 * @schema ReplicationSourceSpecSyncthingConfigCapacity
 */
export class ReplicationSourceSpecSyncthingConfigCapacity {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecSyncthingConfigCapacity {
    return new ReplicationSourceSpecSyncthingConfigCapacity(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecSyncthingConfigCapacity {
    return new ReplicationSourceSpecSyncthingConfigCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * MoverAffinity allows specifying the PodAffinity that will be used by the data mover
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinity
 */
export interface ReplicationSourceSpecSyncthingMoverAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinity#nodeAffinity
   */
  readonly nodeAffinity?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinity#podAffinity
   */
  readonly podAffinity?: ReplicationSourceSpecSyncthingMoverAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinity(
  obj: ReplicationSourceSpecSyncthingMoverAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity(
        obj.nodeAffinity,
      ),
    "podAffinity":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinity(
        obj.podAffinity,
      ),
    "podAntiAffinity":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity(
        obj.podAntiAffinity,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents compute resources required by the data mover container.
 * Immutable.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
 * This should only be used by advanced users as this can result in a mover
 * pod being unschedulable or crashing due to limited resources.
 *
 * @schema ReplicationSourceSpecSyncthingMoverResources
 */
export interface ReplicationSourceSpecSyncthingMoverResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema ReplicationSourceSpecSyncthingMoverResources#claims
   */
  readonly claims?: ReplicationSourceSpecSyncthingMoverResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecSyncthingMoverResources#limits
   */
  readonly limits?: {
    [key: string]: ReplicationSourceSpecSyncthingMoverResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ReplicationSourceSpecSyncthingMoverResources#requests
   */
  readonly requests?: {
    [key: string]: ReplicationSourceSpecSyncthingMoverResourcesRequests;
  };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverResources(
  obj: ReplicationSourceSpecSyncthingMoverResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MoverSecurityContext allows specifying the PodSecurityContext that will
 * be used by the data mover
 *
 * @schema ReplicationSourceSpecSyncthingMoverSecurityContext
 */
export interface ReplicationSourceSpecSyncthingMoverSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?:
    ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID, the fsGroup (if specified), and group memberships
   * defined in the container image for the uid of the container process. If unspecified,
   * no additional groups are added to any container. Note that group memberships
   * defined in the container image for the uid of the container process are still effective,
   * even if they are not included in this list.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#sysctls
   */
  readonly sysctls?:
    ReplicationSourceSpecSyncthingMoverSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverSecurityContext(
  obj: ReplicationSourceSpecSyncthingMoverSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "appArmorProfile":
      toJson_ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverSecurityContextSysctls(y)
    ),
    "windowsOptions":
      toJson_ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SyncthingPeer Defines the necessary information needed by VolSync
 * to configure a given peer with the running Syncthing instance.
 *
 * @schema ReplicationSourceSpecSyncthingPeers
 */
export interface ReplicationSourceSpecSyncthingPeers {
  /**
   * The peer's Syncthing ID.
   *
   * @schema ReplicationSourceSpecSyncthingPeers#ID
   */
  readonly id: string;

  /**
   * The peer's address that our Syncthing node will connect to.
   *
   * @schema ReplicationSourceSpecSyncthingPeers#address
   */
  readonly address: string;

  /**
   * A flag that determines whether this peer should
   * introduce us to other peers sharing this volume.
   * It is HIGHLY recommended that two Syncthing peers do NOT
   * set each other as introducers as you will have a difficult time
   * disconnecting the two.
   *
   * @schema ReplicationSourceSpecSyncthingPeers#introducer
   */
  readonly introducer: boolean;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingPeers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingPeers(
  obj: ReplicationSourceSpecSyncthingPeers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ID": obj.id,
    "address": obj.address,
    "introducer": obj.introducer,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinity
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinity(
  obj: ReplicationSourceSpecRcloneMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinity
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinity(
  obj: ReplicationSourceSpecRcloneMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity(
  obj: ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationSourceSpecRcloneMoverResourcesClaims
 */
export interface ReplicationSourceSpecRcloneMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationSourceSpecRcloneMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverResourcesClaims(
  obj: ReplicationSourceSpecRcloneMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationSourceSpecRcloneMoverResourcesLimits
 */
export class ReplicationSourceSpecRcloneMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRcloneMoverResourcesLimits {
    return new ReplicationSourceSpecRcloneMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRcloneMoverResourcesLimits {
    return new ReplicationSourceSpecRcloneMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationSourceSpecRcloneMoverResourcesRequests
 */
export class ReplicationSourceSpecRcloneMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRcloneMoverResourcesRequests {
    return new ReplicationSourceSpecRcloneMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRcloneMoverResourcesRequests {
    return new ReplicationSourceSpecRcloneMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile
 */
export interface ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationSourceSpecRcloneMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationSourceSpecRcloneMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile
 */
export interface ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationSourceSpecRcloneMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationSourceSpecRcloneMoverSecurityContextSysctls
 */
export interface ReplicationSourceSpecRcloneMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverSecurityContextSysctls(
  obj: ReplicationSourceSpecRcloneMoverSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions
 */
export interface ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationSourceSpecRcloneMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinity
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinity(
  obj: ReplicationSourceSpecResticMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinity
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinity(
  obj: ReplicationSourceSpecResticMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinity
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinity(
  obj: ReplicationSourceSpecResticMoverAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationSourceSpecResticMoverResourcesClaims
 */
export interface ReplicationSourceSpecResticMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationSourceSpecResticMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverResourcesClaims(
  obj: ReplicationSourceSpecResticMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationSourceSpecResticMoverResourcesLimits
 */
export class ReplicationSourceSpecResticMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecResticMoverResourcesLimits {
    return new ReplicationSourceSpecResticMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecResticMoverResourcesLimits {
    return new ReplicationSourceSpecResticMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationSourceSpecResticMoverResourcesRequests
 */
export class ReplicationSourceSpecResticMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecResticMoverResourcesRequests {
    return new ReplicationSourceSpecResticMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecResticMoverResourcesRequests {
    return new ReplicationSourceSpecResticMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile
 */
export interface ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationSourceSpecResticMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationSourceSpecResticMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecResticMoverSecurityContextSeccompProfile
 */
export interface ReplicationSourceSpecResticMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationSourceSpecResticMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationSourceSpecResticMoverSecurityContextSysctls
 */
export interface ReplicationSourceSpecResticMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverSecurityContextSysctls(
  obj: ReplicationSourceSpecResticMoverSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationSourceSpecResticMoverSecurityContextWindowsOptions
 */
export interface ReplicationSourceSpecResticMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationSourceSpecResticMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecResticMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationSourceSpecResticMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationSourceSpecRsyncMoverResourcesClaims
 */
export interface ReplicationSourceSpecRsyncMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationSourceSpecRsyncMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncMoverResourcesClaims(
  obj: ReplicationSourceSpecRsyncMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationSourceSpecRsyncMoverResourcesLimits
 */
export class ReplicationSourceSpecRsyncMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRsyncMoverResourcesLimits {
    return new ReplicationSourceSpecRsyncMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRsyncMoverResourcesLimits {
    return new ReplicationSourceSpecRsyncMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationSourceSpecRsyncMoverResourcesRequests
 */
export class ReplicationSourceSpecRsyncMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRsyncMoverResourcesRequests {
    return new ReplicationSourceSpecRsyncMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRsyncMoverResourcesRequests {
    return new ReplicationSourceSpecRsyncMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity(
  obj: ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity(
  obj: ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity(
  obj: ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverResourcesClaims
 */
export interface ReplicationSourceSpecRsyncTlsMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverResourcesClaims(
  obj: ReplicationSourceSpecRsyncTlsMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationSourceSpecRsyncTlsMoverResourcesLimits
 */
export class ReplicationSourceSpecRsyncTlsMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRsyncTlsMoverResourcesLimits {
    return new ReplicationSourceSpecRsyncTlsMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRsyncTlsMoverResourcesLimits {
    return new ReplicationSourceSpecRsyncTlsMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationSourceSpecRsyncTlsMoverResourcesRequests
 */
export class ReplicationSourceSpecRsyncTlsMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecRsyncTlsMoverResourcesRequests {
    return new ReplicationSourceSpecRsyncTlsMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecRsyncTlsMoverResourcesRequests {
    return new ReplicationSourceSpecRsyncTlsMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile
 */
export interface ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile
 */
export interface ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls
 */
export interface ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls(
  obj: ReplicationSourceSpecRsyncTlsMoverSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions
 */
export interface ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity(
  obj: ReplicationSourceSpecSyncthingMoverAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinity
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinity(
  obj: ReplicationSourceSpecSyncthingMoverAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity(
  obj: ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ReplicationSourceSpecSyncthingMoverResourcesClaims
 */
export interface ReplicationSourceSpecSyncthingMoverResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema ReplicationSourceSpecSyncthingMoverResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverResourcesClaims(
  obj: ReplicationSourceSpecSyncthingMoverResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationSourceSpecSyncthingMoverResourcesLimits
 */
export class ReplicationSourceSpecSyncthingMoverResourcesLimits {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecSyncthingMoverResourcesLimits {
    return new ReplicationSourceSpecSyncthingMoverResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecSyncthingMoverResourcesLimits {
    return new ReplicationSourceSpecSyncthingMoverResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ReplicationSourceSpecSyncthingMoverResourcesRequests
 */
export class ReplicationSourceSpecSyncthingMoverResourcesRequests {
  public static fromNumber(
    value: number,
  ): ReplicationSourceSpecSyncthingMoverResourcesRequests {
    return new ReplicationSourceSpecSyncthingMoverResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ReplicationSourceSpecSyncthingMoverResourcesRequests {
    return new ReplicationSourceSpecSyncthingMoverResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile
 */
export interface ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile(
  obj:
    | ReplicationSourceSpecSyncthingMoverSecurityContextAppArmorProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions
 */
export interface ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions(
  obj:
    | ReplicationSourceSpecSyncthingMoverSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile
 */
export interface ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile(
  obj:
    | ReplicationSourceSpecSyncthingMoverSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSysctls
 */
export interface ReplicationSourceSpecSyncthingMoverSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverSecurityContextSysctls(
  obj: ReplicationSourceSpecSyncthingMoverSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions
 */
export interface ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions(
  obj:
    | ReplicationSourceSpecSyncthingMoverSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "mismatchLabelKeys": obj.mismatchLabelKeys?.map((y) => y),
    "namespaceSelector":
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationSourceSpecResticMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRcloneMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecResticMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecRsyncTlsMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ReplicationSourceSpecSyncthingMoverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */
